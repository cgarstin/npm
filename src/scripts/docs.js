import PATH from 'path';
import FS from 'fs';
import HandleBars from 'handlebars';
import Git from 'nodegit';
import JSDoc2Md from 'jsdoc-to-markdown';
import { $, Subject } from '@gik/tools-streamer';
import Out from '../out';
import Path from '../path';
import { $fromConfig, Package } from '../config';

// No, I don't want to be tracked, thank you.
JSDoc2Md._usage.disable(); // eslint-disable-line no-underscore-dangle

/**
 * @module docs
 * @memberof gik-npm.Scripts
 * @type {script}
 * @description Generates documentation using [js-to-markdown](http://github.com/jsdoc-to-markdown/jsdoc-to-markdown).
 * The template used for the documentation is customised, you can see how it looks here,
 * since this very documentation was generated by it. This is why even though this script
 * uses js-to-markdown several of their configuration propertes are not available due to
 * the heavy customisation it was done to its original template. Howevet the followin
 * ARE avaialble.
 * ###### Default `jsdoc.json` config
 * ```javascript
 * <<<file:root/.jsdocrc>>>
 * ````
 *
 * @property {Object} jsdoc - Options for the documentation generator.
 * @property {string} [jsdoc.template=./template/README.md] - The location of documentation
 * template.
 * @property {boolean} [private=false] - Wether to show private members or not.
 * @property {string} [configure=root/.jsdocrc] - An example of the base configuration is
 * shown below.
 *
 * @TODO Write documentation about how to customize the template and the available helpers.
 */
export default function Docs() {

    const filename = 'README.md';

    // Converts the config$ into a hot observable, so it only runs once.
    const subject = new Subject();
    $fromConfig().subscribe(subject);
    const config$ = new $(observer => subject.subscribe(observer));

    const body$ = config$
        .map(config => ({
            ...config[Package.name].jsdoc,
            files: PATH.join(PATH.resolve(config.directories.src), '**', '*.js'),
        }))
        .switchMap(config => $
            .fromFileRead(config.template)
            .map(template => ({ ...config, template })),
        )
        .map((config) => {
            // for some reason if the private config comes as false, babel breaks.
            // so it's either true  or undefined.
            config.private = !!config.private || undefined;
            return config;
        })
        .switchMap(config => $.fromPromise(JSDoc2Md.render(config)))
        // convert raw handlebars blocks back no normal, so the seconf pass can process'em
        // .map(content => content.replace(/\\)\{\{\{/g, '{{{'));
        .map((content) => {
            if (content.indexOf('<<<file:') === -1) return content;
            return content.replace(/<<<file:([^>]+)>>>/g, (str, match) => {
                const [dir, base] = match.split('/');
                // TODO: This should be done async using streams.
                return FS.readFileSync(PATH.join(Path[dir], base), 'utf-8');
            });
        });

    const header$ = config$.switchMap(config => $
        .fromFileRead(PATH.join(PATH.resolve(config.directories.template), filename)),
    );

    // .map(content => Mustache(content, config)),
    return $
        .combineLatest(body$, header$, config$)
        // Compile using HandleBars static instance set by jsdoc-to-markdown
        // NOTE: every helper registered with jsdoc-to-markdown will be available
        .map(([body, header, config]) => HandleBars.compile(`${header}\n${body}`)(config))
        .switchMap(content => $.fromFileWrite(PATH.join(Path.root, filename), content))
        .mapTo(PATH.join('.', filename))
        .switchMap(path => $
            .from(Git.Repository.open(Path.cwd))
            .switchMap(repo => $
                .from(repo.index())
                .switchMap(index => $
                    .from(index.addByPath(path))
                    .mapTo(index),
                )
                .switchMap(index => $.from(index.write())),
            )
            .mapTo(`Docs generated on ${path} and added to Git`),
        )
        .subscribe(Out.good, Out.bad);
}
